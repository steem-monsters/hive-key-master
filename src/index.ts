import { Client, generateKeys, generatePassword, PrivateKey, PublicKey } from 'splinterlands-dhive-sl';
import * as readline from 'readline-sync';
import fs from 'fs';
import { config } from 'dotenv';
config();

type AuthorityType = 'posting' | 'active' | 'owner';

const authorityTypes: AuthorityType[] = ['posting', 'active', 'owner'];

let broadcastAccounts: [string, { active?: string; owner?: string }] = [] as any;

const client = new Client();

export const requestInput = async () => {
    console.log('This script will allow you to add/remove posting/active keys on your Hive account');
    let name = '';
    if (broadcastAccounts.length > 0) {
        const bAccountIndex = readline.keyInSelect(broadcastAccounts.map((bAccount) => bAccount[0]).concat(['Enter account name']), 'Choose Hive account or enter a new account: ');
        if (bAccountIndex === -1) process.exit(1);
        name = broadcastAccounts.map((bAccount) => bAccount[0])[bAccountIndex];
    }
    if (!name) {
        name = readline.question(`Enter your Hive account: `);
    }

    const account = await client.database.getAccount(name);
    if (!account) throw Error('Account does not exist');

    console.log('\n----------------------------------');

    const authorityTypeIndex = readline.keyInSelect(authorityTypes, 'Choose the authority type: ');
    const authorityType = authorityTypes[authorityTypeIndex];
    if (!authorityType) process.exit(1);

    console.log('\n----------------------------------');

    const methodIndex = readline.keyInSelect(['add', 'remove'], 'Choose the method: ');
    const method = ['add', 'remove'][methodIndex];
    if (!method) process.exit(1);

    if (authorityType === 'owner' || authorityType === 'active') {
        const warningConfirmation = readline.keyInYN(`\n\nWARNING: You're about to remove an ${authorityType} key. Please make sure you know what you're doing!!`);
        if (!warningConfirmation) process.exit(1);
    }

    console.log('\n----------------------------------');

    let key = '';
    if (method === 'remove') {
        const existingKeys = account[authorityType].key_auths.map((keyArray) => PublicKey.from(keyArray[0]).toString());
        const keyIndex = readline.keyInSelect(existingKeys, 'Choose key to remove: ');
        key = existingKeys[keyIndex];
        if (!key) process.exit(1);
    } else {
        key = readline.question(`\nEnter the public or private key to add (Leave empty to have a key-pair generated by the script): `, {
            hideEchoBack: true,
        });
    }

    console.log('\n----------------------------------');

    let privateBroadcastKey = '';
    const broadcastAccount = broadcastAccounts.filter((bAccount) => bAccount[0] === name)[0];
    if (broadcastAccount && broadcastAccount[1][authorityType === 'owner' ? 'owner' : 'active']) {
        privateBroadcastKey = broadcastAccount[1][authorityType === 'owner' ? 'owner' : 'active'];
    }

    if (!privateBroadcastKey) {
        privateBroadcastKey = readline.question(
            `\nEnter the private ${authorityType === 'owner' ? 'owner' : 'active'} key needed to broadcast the transaction to the blockchain: `,
            {
                hideEchoBack: true,
            },
        );
        console.log('\n----------------------------------\n');
    }

    return { name, authorityType, key, privateBroadcastKey, method };
};

export const main = async () => {
    try {
        broadcastAccounts = JSON.parse(process.env.BROADCAST_ACCOUNTS || '') || [];
    } catch (error) {
        console.error(`Can't load accounts from .env file. Make sure it's in the correct format.\n`);
    }

    const { name, authorityType, method, privateBroadcastKey, key } = await requestInput();

    const account = await client.database.getAccount(name);
    if (!account) throw Error('Account does not exist');

    let keyPair = { privateKey: '', pubKey: '' };
    if (!key) {
        const keys = generateKeys(name, generatePassword());
        keyPair = { privateKey: keys.posting, pubKey: keys.postingPubkey };
    } else {
        keyPair = key.startsWith('STM')
            ? { privateKey: 'omitted', pubKey: key }
            : {
                  privateKey: key,
                  pubKey: PrivateKey.from(key).createPublic().toString(),
              };
    }

    console.log('Review', { account: name, authorityType, method, pubKey: keyPair.pubKey, privateKey: !key ? keyPair.privateKey : 'omitted' });
    const confirmation = readline.keyInYN('\nDo you want to update your account keys based on the above data?');
    if (confirmation) {
        console.log('\nBroadcasting to the blockchain. Please wait.');
        const result = await client.broadcast.updateAccountKeys(name, authorityType, method as any, keyPair.pubKey, privateBroadcastKey);
        console.log(`Result: ${result.status === 'success' ? 'SUCCESS' : 'ERROR'}`, result.data);

        const confirmationBackup = readline.keyInYN('\nDo you want to save the backup?');
        if (confirmationBackup) {
            await fs.promises.mkdir('backups', { recursive: true });
            fs.writeFileSync(`backups/${Date.now()}-${name}-${method}-${authorityType}.txt`, JSON.stringify({ account: name, authorityType, method, ...keyPair }));
            console.log(`Saved backup to backups/${Date.now()}-${name}-${method}-${authorityType}.txt`);
        }
    } else {
        console.log('\nCancelling based on user request');
    }

    process.exit(1);
};

main();

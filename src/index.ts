import { Client, PrivateKey, AccountUpdateOperation } from '@hiveio/dhive';
import { utils } from 'splinterlands-auth';
import * as readline from 'readline-sync';
import fs from 'fs';
import { config } from 'dotenv';
config();

type AuthorityType = 'posting' | 'active' | 'owner';

const authorityTypes: AuthorityType[] = ['posting', 'active', 'owner'];

let broadcastAccounts: [string, { active?: string; owner?: string }] = [] as any;

export const requestInput = async () => {
    console.log('This script will allow you to add/remove posting/active keys on your Hive account');

    let name = '';
    if (broadcastAccounts.length > 0) {
        const bAccountIndex = readline.keyInSelect(broadcastAccounts.map((bAccount) => bAccount[0]).concat(['Enter account name']), 'Choose Hive account or enter a new account: ');
        if (bAccountIndex === -1) process.exit(1);
        name = broadcastAccounts.map((bAccount) => bAccount[0])[bAccountIndex];
    }
    if (!name) {
        name = readline.question(`Enter your Hive account: `);
    }

    const account = await utils.getHiveAccount(name);
    if (!account) throw Error('Account does not exist');

    console.log('\n----------------------------------');

    const authorityTypeIndex = readline.keyInSelect(authorityTypes, 'Choose the authority type: ');
    const authorityType = authorityTypes[authorityTypeIndex];
    if (!authorityType) process.exit(1);

    console.log('\n----------------------------------');

    const methodIndex = readline.keyInSelect(['add', 'remove'], 'Choose the method: ');
    const method = ['add', 'remove'][methodIndex];
    if (!method) process.exit(1);

    if (authorityType === 'owner' || authorityType === 'active') {
        const warningConfirmation = readline.keyInYN(`\n\nWARNING: You're about to remove an ${authorityType} key. Please make sure you know what you're doing!!`);
        if (!warningConfirmation) process.exit(1);
    }

    console.log('\n----------------------------------');

    let key = '';
    if (method === 'remove') {
        const existingKeys = account[authorityType].key_auths.map((keyArray) => keyArray[0]);
        const keyIndex = readline.keyInSelect(existingKeys, 'Choose key to remove: ');
        key = existingKeys[keyIndex];
        if (!key) process.exit(1);
    } else {
        key = readline.question(`\nEnter the public or private key to add (Leave empty to have a key-pair generated by the script): `, {
            hideEchoBack: true,
        });
    }

    console.log('\n----------------------------------');

    let privateBroadcastKey = '';
    const broadcastAccount = broadcastAccounts.filter((bAccount) => bAccount[0] === name)[0];
    if (broadcastAccount && broadcastAccount[1][authorityType === 'owner' ? 'owner' : 'active']) {
        privateBroadcastKey = broadcastAccount[1][authorityType === 'owner' ? 'owner' : 'active'];
    }

    if (!privateBroadcastKey) {
        privateBroadcastKey = readline.question(
            `\nEnter the private ${authorityType === 'owner' ? 'owner' : 'active'} key needed to broadcast the transaction to the blockchain: `,
            {
                hideEchoBack: true,
            },
        );
        console.log('\n----------------------------------\n');
    }

    return { name, authorityType, key, privateBroadcastKey, method };
};

export const main = async () => {
    try {
        broadcastAccounts = JSON.parse(process.env.BROADCAST_ACCOUNTS || '') || [];
    } catch (error) {
        console.error(`Can't load accounts from .env file. Make sure it's in the correct format.`);
    }

    const { name, authorityType, method, privateBroadcastKey, key } = await requestInput();

    const client = new Client('https://api.hive.blog');

    const account = await utils.getHiveAccount(name);
    if (!account) throw Error('Account does not exist');

    let keyPair = { privateKey: '', pubKey: '' };
    if (!key) {
        const keys = utils.generateKeys(name, utils.generatePassword());
        keyPair = { privateKey: keys.posting, pubKey: keys.postingPubkey };
    } else {
        keyPair = key.startsWith('STM')
            ? { privateKey: 'omitted', pubKey: key }
            : {
                  privateKey: key,
                  pubKey: PrivateKey.from(key).createPublic().toString(),
              };
    }

    const authority = account[authorityType];
    if (method === 'remove') {
        authority.key_auths = authority.key_auths.filter((k) => k[0] !== keyPair.pubKey);
        if (authority.key_auths.length < 1) throw Error(`Can't reduce keys to less than 1`);
    } else {
        authority.key_auths.push([keyPair.pubKey, 1]);
        authority.key_auths = authority.key_auths.sort((a, b) => a[0].localeCompare(b[0]));
    }

    const data: AccountUpdateOperation[1] = {
        account: name,
        json_metadata: account.json_metadata,
        memo_key: account.memo_key,
        active: account.active,
        posting: account.posting,
    };

    data[authorityType] = authority;

    console.log('Review', { account: name, authorityType, method, pubKey: keyPair.pubKey, privateKey: !key ? keyPair.privateKey : 'omitted' });
    const confirmation = readline.keyInYN('\nDo you want to update your account keys based on the above data?');
    if (confirmation) {
        console.log('Broadcasting to the blockchain. Please wait.');
        const result = await client.broadcast.updateAccount(data, PrivateKey.from(privateBroadcastKey));
        console.log(`Result: ${result.id ? 'SUCCESS' : 'ERROR'}`, result);

        const confirmationBackup = readline.keyInYN('\nDo you want to save the backup?');
        if (confirmationBackup) {
            await fs.promises.mkdir('backups', { recursive: true });
            fs.writeFileSync(`backups/${Date.now()}-${name}-${method}-${authorityType}.txt`, JSON.stringify({ account: name, authorityType, method, ...keyPair }));
            console.log(`Saved backup to backups/${Date.now()}-${name}-${method}-${authorityType}.txt`);
        }
    } else {
        console.log('Cancelling based on user request');
    }

    process.exit(1);
};

main();

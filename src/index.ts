import {
    AccountAuthorityType,
    Client,
    generateKeys,
    generatePassword,
    KeyRoleActive,
    KeyRoleOwner,
    KeyRolePosting,
    PrivateKey,
    PublicKey,
    UpdateAccountAuthorityMethod,
} from 'splinterlands-dhive-sl';
import * as readline from 'readline-sync';
import fs from 'fs';
import { config } from 'dotenv';
config();

const authorityTypes: (AccountAuthorityType | 'threshold')[] = ['key', 'account', 'threshold'];
const authorityRoles: (KeyRoleActive | KeyRoleOwner | KeyRolePosting)[] = ['posting', 'active', 'owner'];

let broadcastAccounts: [string, { active?: string; owner?: string }] = [] as any;

const client = new Client();

export const requestInput = async () => {
    console.log('This script will allow you to manage your authorities on your Hive account');
    let name = '';
    if (broadcastAccounts.length > 0) {
        const bAccountIndex = readline.keyInSelect(broadcastAccounts.map((bAccount) => bAccount[0]).concat(['Enter account name']), 'Choose Hive account or enter a new account: ');
        if (bAccountIndex === -1) process.exit(1);
        name = broadcastAccounts.map((bAccount) => bAccount[0])[bAccountIndex];
    }
    if (!name) {
        name = readline.question(`Enter your Hive account: `);
    }

    const account = await client.database.getAccount(name);
    if (!account) throw Error('Account does not exist');

    /**
     * Choose whether 'key' or 'account' should be added/remove or whether the threshold should be updated
     */
    console.log('\n----------------------------------');
    const authorityTypeIndex = readline.keyInSelect(authorityTypes, 'Choose the authority type: ');
    const authorityType = authorityTypes[authorityTypeIndex];
    if (!authorityType) process.exit(1);

    /**
     * Choose which role out of 'posting', 'active' or 'owner' should be changed
     */
    console.log('\n----------------------------------');
    const authorityRoleIndex = readline.keyInSelect(authorityRoles, 'Choose the authority role: ');
    const role = authorityRoles[authorityRoleIndex];
    if (!role) process.exit(1);

    /**
     * Show warning if role is 'owner' or 'active'
     */
    if (role === 'owner' || role === 'active') {
        const warningConfirmation = readline.keyInYN(`\n\nWARNING: You're about to change the ${role} role. Please make sure you know what you're doing!!`);
        if (!warningConfirmation) process.exit(1);
    }

    let key = '';
    let method: UpdateAccountAuthorityMethod = 'add';
    let threshold = 0;

    /**
     * Show current threshold and ask for new threshold
     */
    if (authorityType === 'threshold') {
        console.log('\n----------------------------------');
        threshold = readline.questionInt(`Current threshold: ${account[role].weight_threshold}. Enter new threshold:`);
        if (threshold === account[role].weight_threshold || threshold <= 0) {
            console.log(`Invalid threshold of ${threshold}`);
            process.exit(1);
        }
    } else {
        /**
         * Choose whether authority should be added or removed
         */
        console.log('\n----------------------------------');
        const methodIndex = readline.keyInSelect(['add', 'remove'], 'Choose the method: ');
        method = ['add', 'remove'][methodIndex] as 'add' | 'remove';
        if (!method) process.exit(1);

        console.log('\n----------------------------------');
        /**
         * Chosen 'remove', so check account for authority and ask user to choose
         */
        if (method === 'remove') {
            const existingAuths = account[role][`${authorityType}_auths`].map((a) => (authorityType === 'key' ? [PublicKey.from(a[0]).toString(), a[1]] : a));
            const keyIndex = readline.keyInSelect(existingAuths, `Choose ${authorityType} to remove: `);
            key = existingAuths[keyIndex][0];
            if (!key) process.exit(1);
        } else {
            /**
             * Chosen 'add', so ask user for new authority or generate a new one if authorityType is 'key' and none is given by user
             */
            key = readline.question(
                authorityType === 'key' ? `\nEnter the public or private key to add (Leave empty to have a key-pair generated by the script): ` : `\nEnter the account to add: `,
                {
                    hideEchoBack: authorityType === 'key',
                },
            );
        }
    }

    console.log('\n----------------------------------');

    /**
     * If .env has private key, use that one
     */
    let privateBroadcastKey = '';
    const broadcastAccount = broadcastAccounts.filter((bAccount) => bAccount[0] === name)[0];
    if (broadcastAccount && broadcastAccount[1][role === 'owner' ? 'owner' : 'active']) {
        privateBroadcastKey = broadcastAccount[1][role === 'owner' ? 'owner' : 'active'];
    }

    /**
     * If .env does not have private-key, ask user to enter private key
     */
    if (!privateBroadcastKey) {
        privateBroadcastKey = readline.question(`\nEnter the private ${role === 'owner' ? 'owner' : 'active'} key needed to broadcast the transaction to the blockchain: `, {
            hideEchoBack: true,
        });
        console.log('\n----------------------------------\n');
    }

    return { name, authorityType, role, key, privateBroadcastKey, method, threshold };
};

export const main = async () => {
    /**
     * Load private keys from .env
     */
    try {
        broadcastAccounts = JSON.parse(process.env.BROADCAST_ACCOUNTS || '') || [];
    } catch (error) {
        console.error(`Can't load accounts from .env file. Make sure it's in the correct format.\n`);
    }

    /**
     * Trigger command line inputs
     */
    const { name, authorityType, role, method, privateBroadcastKey, key, threshold } = await requestInput();

    /**
     * Get account again (just in case something changed in the meantime)
     */
    const account = await client.database.getAccount(name);
    if (!account) throw Error('Account does not exist');

    let authority = '';
    let keyPair = { privateKey: '', pubKey: '' };

    /**
     * Threshold should be changed
     */
    if (authorityType === 'threshold') {
        console.log('Review', { account: name, role, authorityType, threshold });
        const confirmation = readline.keyInYN('\nDo you want to update your account based on the above data?');
        if (confirmation) {
            /**
             * Broadcast to blockchain
             */
            console.log('\nBroadcasting to the blockchain. Please wait.');
            const result = await client.broadcast.updateAccountAuthorityThreshold(
                {
                    account: name,
                    threshold,
                    role,
                },
                privateBroadcastKey,
            );
            console.log(`Result: `, result);
        } else {
            console.log('\nCancelling based on user request');
        }
    } else {
        /**
         * Key should be added/removed
         */
        if (authorityType === 'key') {
            if (!key) {
                const keys = generateKeys(name, generatePassword());
                keyPair = { privateKey: keys.posting, pubKey: keys.postingPubkey };
            } else {
                keyPair = key.startsWith('STM')
                    ? { privateKey: 'omitted', pubKey: key }
                    : {
                          privateKey: key,
                          pubKey: PrivateKey.from(key).createPublic().toString(),
                      };
            }
            authority = keyPair.pubKey;
            console.log('Review', { account: name, role, method, authority, privateKey: !key ? keyPair.privateKey : 'omitted' });
        } else {
            /**
             * Account should be added/removed
             */
            authority = key;
            console.log('Review', { account: name, role, method, authority });
        }

        const confirmation = readline.keyInYN('\nDo you want to update your account keys based on the above data?');
        if (confirmation) {
            /**
             * Broadcast to blockchain
             */
            console.log('\nBroadcasting to the blockchain. Please wait.');
            const result = await client.broadcast.updateAccountAuthority(
                {
                    method,
                    account: name,
                    authority,
                    authorityType,
                    role,
                },
                privateBroadcastKey,
            );
            console.log(`Result: `, result);
            const confirmationBackup = readline.keyInYN('\nDo you want to save the backup?');
            if (confirmationBackup) {
                await fs.promises.mkdir('backups', { recursive: true });
                fs.writeFileSync(
                    `backups/${Date.now()}-${name}-${method}-${role}.txt`,
                    JSON.stringify({ account: name, role, method, authority: keyPair.pubKey ? keyPair : authority }),
                );
                console.log(`Saved backup to backups/${Date.now()}-${name}-${method}-${role}.txt`);
            }
        } else {
            console.log('\nCancelling based on user request');
        }
    }

    process.exit(1);
};

main();
